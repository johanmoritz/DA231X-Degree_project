\chapter{Discussion}
\todo[inline]{This can be a separate chapter or a section
	in the previous chapter.}
\label{ch:discussion}
\todo[inline, backgroundcolor=kth-lightblue]{Diskussion\\
	Förbättringsförslag?}

\section{Model relevance}

While TLA\textsuperscript+ models are useful to test and describe complex systems, to show their relevance they need to correspond to a real implementation. While this work does not include a system implementation, this section describe how one could be made which behaves equivalently to the model with regards to the models correctness properties. The main difference between the system model and a possible implementation is that the later is constrained as well as enhanced by Hyperledger Fabric, on which foundation it would be built. Many of the key security assumptions of the system such as integrity, availability, authentication and authorization rely on Fabrics default behaviour. An implementation built on Hyperledger Fabric can be seen as a refinement of (parts of) the model. To, then, show that an implementation of the model exists, an informal argument is given to claim that the TLA\textsuperscript+ model can be refined into an implementation built on Hyperledger Fabric.

Besides the use of Hyperledger Fabric, the two most notable differences between the model described under chapter \ref{ch:Model} and a real system implementation are (a) the lack of cryptographic primitives such as HMAC to support two-phase commit of judgment votes and (b) the assumptions of how users of the system behave and act. These discrepancies are discussed under sections \ref{subsec:DiscussionTwoPhaseCommit} and \ref{subsec:DiscussionBehaviourAssumptions}.

\subsection{Hyperledger fabric highlights}
\label{subsec:hyperledger-highlights}

The Hyperledger Fabric blockchain is extensively described in section \ref{sec:hyperledger-fabric}, but to aid the reader this section highlights the parts most relevant to a model-implementation translation. In Hyperledger Fabric, systems are defined as a set of organizations, a network of nodes each owned by one of the organizations, a set of general policies for how the network is managed and a set of chaincode smart contracts which can read and update the blockchain and worldstate. Every node has some role on the system, such as peers that store the blockchain and run chaincode or orderers that ensures all nodes have the same blockchain history. To support high availability, participating organizations can have several nodes with the same role, thus distributing the load on any one node as well as mitigating risk in the case where some node is not functioning properly. Chaincodes are written in regular turing-complete programming languages such as Java or Go. For them to be accepted by the network, chaincodes should be deterministic with regards to the read-write sets they generate. If a chaincode contains non-deterministic behaviour, different peers would not be able to reach the same result when running the chaincode. This would lead the network to reject the execution. Whether they are accepted or not is highly dependent on the chaincodes' endorsement policies which describe what organizations has to accept the run. While chaincodes can read any parts of the world state, the request parameters of a chaincode call can include information private only to the organization that invoked the request in first hand.

\subsection{Model to network design}
The TLA\textsuperscript+ model uses a simplified network topology compared to what is expected in a production system. In the model, each organization is represented by a single \texttt{builder}. These builders are actors in the model and play the roles of clients and peers in the network. While not recommended, there is nothing in Hyperledger Fabric stopping a network to have such single node organizations. In fact, this is precisely how the Hyperledger test-network is set up. While the model can be said to represent clients and peers, it does not have anything similar to orderer nodes. Instead, the model abstracts the transaction flow (see \ref{subsec:transaction-flow}) as guaranteed and atomic state updates. This is consistent with the guarantees Hyperledger Fabric makes, where any chaincode invocation should lead to the same state updates on every peer.

To represent the Hyperledger Fabric world state, the key-value map variable \texttt{public} contains all publicly known (throughout the network) information. Similarly to how the world state on the blockchain can only be updated by chaincode, there is a limited number of operators that reads or writes to the \texttt{public} variable.

\subsection{Model to chaincode}

Because Hyperledger Fabric chaincode are written in turing-complete languages it is fully possible to translate TLA\textsuperscript+ code to one of those languages. This greatly simplifies the argument for whether a corresponding implementation \textit{can} be found for the model. The resulting chaincode definitions should be functional as long as adherence is made to follow the Hyperledger Fabric chaincode API. Relevant to this translation are the five TLA\textsuperscript+ operators described in section \ref{subsec:ModelChaincode}, each containing the functionality of a corresponding chaincode. In general, these operators all have the form of taking some parameters from a caller, verifying whether the call is valid and updating the \texttt{public} state. This way of defining chaincode can be seen in many of the Hyperledger Fabric examples \textbf{cite}. As mentioned in \ref{subsec:hyperledger-highlights}, chaincodes should be deterministic and can rely on private data only available to nodes of the same organization as the invoking client. The five operators in the model corresponding to chaincodes are all deterministic and rely only on the information in the \texttt{public} variable and their parameters, so it is possible to infer that they could be translated into actual chaincode.

\subsection{Two-phase commit}
\label{subsec:DiscussionTwoPhaseCommit}

\subsection{System-actor behaviour}
\label{subsec:DiscussionBehaviourAssumptions}

The model assumptions of how system-actors behave are laid out in section \ref{subsec:ModelSpec}.


\subsection{Translation summary}